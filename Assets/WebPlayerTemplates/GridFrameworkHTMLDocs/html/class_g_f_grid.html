<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Grid Framework: GFGrid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Framework
   &#160;<span id="projectnumber">1.3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_g_f_grid.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#events">Events</a> &#124;
<a href="class_g_f_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GFGrid Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for all Grid Framework grids.  
 <a href="class_g_f_grid.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for GFGrid:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_g_f_grid.png" usemap="#GFGrid_map" alt=""/>
  <map id="GFGrid_map" name="GFGrid_map">
<area href="class_g_f_layered_grid.html" title="The parent class for all layered grids. " alt="GFLayeredGrid" shape="rect" coords="55,56,155,80"/>
<area href="class_g_f_rect_grid.html" title="A standard three-dimensional rectangular grid. " alt="GFRectGrid" shape="rect" coords="165,56,265,80"/>
<area href="class_g_f_hex_grid.html" title="A grid consting of flat hexagonal grids stacked on top of each other " alt="GFHexGrid" shape="rect" coords="0,112,100,136"/>
<area href="class_g_f_polar_grid.html" title="A polar grid based on cylindrical coordinates. " alt="GFPolarGrid" shape="rect" coords="110,112,210,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab1885761cfdee863857bcf43c44b212d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GridPlane</a> </td></tr>
<tr class="memdesc:ab1885761cfdee863857bcf43c44b212d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for one of the three grid planes.  <a href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">More...</a><br/></td></tr>
<tr class="separator:ab1885761cfdee863857bcf43c44b212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b011f573c51561fbd9e411f821ba820"><td class="memItemLeft" align="right" valign="top">delegate void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a1b011f573c51561fbd9e411f821ba820">GridChangedDelegate</a> (<a class="el" href="class_g_f_grid.html">GFGrid</a> grid)</td></tr>
<tr class="memdesc:a1b011f573c51561fbd9e411f821ba820"><td class="mdescLeft">&#160;</td><td class="mdescRight">A delegate for handling events when the grid has been changed in such a way that it requires a redraw <a href="#a1b011f573c51561fbd9e411f821ba820">More...</a><br/></td></tr>
<tr class="separator:a1b011f573c51561fbd9e411f821ba820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c424ac71404a8c87a958b5b5952eb0f"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a3c424ac71404a8c87a958b5b5952eb0f">WorldToGrid</a> (Vector3 worldPoint)</td></tr>
<tr class="memdesc:a3c424ac71404a8c87a958b5b5952eb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts world coordinates to grid coordinates.  <a href="#a3c424ac71404a8c87a958b5b5952eb0f">More...</a><br/></td></tr>
<tr class="separator:a3c424ac71404a8c87a958b5b5952eb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32d7bfcecb5da3fdc47b972b551e33e"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#af32d7bfcecb5da3fdc47b972b551e33e">GridToWorld</a> (Vector3 gridPoint)</td></tr>
<tr class="memdesc:af32d7bfcecb5da3fdc47b972b551e33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts grid coordinates to world coordinates.  <a href="#af32d7bfcecb5da3fdc47b972b551e33e">More...</a><br/></td></tr>
<tr class="separator:af32d7bfcecb5da3fdc47b972b551e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4705c12317b31bd470d265aaa265db"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a0e4705c12317b31bd470d265aaa265db">NearestVertexW</a> (Vector3 worldPoint, bool doDebug=false)</td></tr>
<tr class="memdesc:a0e4705c12317b31bd470d265aaa265db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the world position of the nearest vertex.  <a href="#a0e4705c12317b31bd470d265aaa265db">More...</a><br/></td></tr>
<tr class="separator:a0e4705c12317b31bd470d265aaa265db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd66db25066777d0c697b71adab5183"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a6fd66db25066777d0c697b71adab5183">NearestFaceW</a> (Vector3 worldPoint, <a class="el" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GridPlane</a> plane, bool doDebug=false)</td></tr>
<tr class="memdesc:a6fd66db25066777d0c697b71adab5183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the world position of the nearest face.  <a href="#a6fd66db25066777d0c697b71adab5183">More...</a><br/></td></tr>
<tr class="separator:a6fd66db25066777d0c697b71adab5183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87a6f38d74c0a6dd222bdd046d781c3"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#ac87a6f38d74c0a6dd222bdd046d781c3">NearestBoxW</a> (Vector3 worldPoint, bool doDebug=false)</td></tr>
<tr class="memdesc:ac87a6f38d74c0a6dd222bdd046d781c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the world position of the nearest box.  <a href="#ac87a6f38d74c0a6dd222bdd046d781c3">More...</a><br/></td></tr>
<tr class="separator:ac87a6f38d74c0a6dd222bdd046d781c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa2821cf118bb4821bd2cbf40029da"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a7eaa2821cf118bb4821bd2cbf40029da">NearestVertexG</a> (Vector3 worldPoint)</td></tr>
<tr class="memdesc:a7eaa2821cf118bb4821bd2cbf40029da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the grid position of the nearest vertex.  <a href="#a7eaa2821cf118bb4821bd2cbf40029da">More...</a><br/></td></tr>
<tr class="separator:a7eaa2821cf118bb4821bd2cbf40029da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac129f3df1da5cdbc31143ecc7db35d2"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#aac129f3df1da5cdbc31143ecc7db35d2">NearestFaceG</a> (Vector3 worldPoint, <a class="el" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GridPlane</a> plane)</td></tr>
<tr class="memdesc:aac129f3df1da5cdbc31143ecc7db35d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the grid position of the nearest Face.  <a href="#aac129f3df1da5cdbc31143ecc7db35d2">More...</a><br/></td></tr>
<tr class="separator:aac129f3df1da5cdbc31143ecc7db35d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7c70449b2449c1e82132e6300cc1a5"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#adb7c70449b2449c1e82132e6300cc1a5">NearestBoxG</a> (Vector3 worldPoint)</td></tr>
<tr class="memdesc:adb7c70449b2449c1e82132e6300cc1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the grid position of the nearest box.  <a href="#adb7c70449b2449c1e82132e6300cc1a5">More...</a><br/></td></tr>
<tr class="separator:adb7c70449b2449c1e82132e6300cc1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188915803f5c902786ae413e7e939bfb"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a188915803f5c902786ae413e7e939bfb">AlignVector3</a> (Vector3 pos, Vector3 scale, <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> ignoreAxis)</td></tr>
<tr class="memdesc:a188915803f5c902786ae413e7e939bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a position vector into the grid.  <a href="#a188915803f5c902786ae413e7e939bfb">More...</a><br/></td></tr>
<tr class="separator:a188915803f5c902786ae413e7e939bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c87287a14b02923c9c28aa9d7478eb5"><td class="memItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a2c87287a14b02923c9c28aa9d7478eb5">AlignVector3</a> (Vector3 pos)</td></tr>
<tr class="separator:a2c87287a14b02923c9c28aa9d7478eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77e71d071ad1d154df8dd6629765def"><td class="memItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#ac77e71d071ad1d154df8dd6629765def">AlignVector3</a> (Vector3 pos, <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> lockAxis)</td></tr>
<tr class="separator:ac77e71d071ad1d154df8dd6629765def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b9392f196d7c87133e343cee64824"><td class="memItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#ac08b9392f196d7c87133e343cee64824">AlignVector3</a> (Vector3 pos, Vector3 scale)</td></tr>
<tr class="separator:ac08b9392f196d7c87133e343cee64824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c627c04505a6a0263ab69d3a08cc16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a07c627c04505a6a0263ab69d3a08cc16">AlignTransform</a> (Transform theTransform, bool rotate, <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> ignoreAxis)</td></tr>
<tr class="memdesc:a07c627c04505a6a0263ab69d3a08cc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits a Transform inside the grid (without scaling it).  <a href="#a07c627c04505a6a0263ab69d3a08cc16">More...</a><br/></td></tr>
<tr class="separator:a07c627c04505a6a0263ab69d3a08cc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4191eeae96aa23f0ced78f4cc7e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a66b4191eeae96aa23f0ced78f4cc7e14">AlignTransform</a> (Transform theTransform)</td></tr>
<tr class="separator:a66b4191eeae96aa23f0ced78f4cc7e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05264e68cae2826694f397e848d58bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a05264e68cae2826694f397e848d58bc8">AlignTransform</a> (Transform theTransform, <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> lockAxis)</td></tr>
<tr class="separator:a05264e68cae2826694f397e848d58bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a7ee949a05d384656ea1b0befbe485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a05a7ee949a05d384656ea1b0befbe485">AlignTransform</a> (Transform theTransform, bool rotate)</td></tr>
<tr class="separator:a05a7ee949a05d384656ea1b0befbe485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de6bd03035124effb4d18b4e731563"><td class="memItemLeft" align="right" valign="top">abstract Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#ae6de6bd03035124effb4d18b4e731563">ScaleVector3</a> (Vector3 scl, <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> ignoreAxis)</td></tr>
<tr class="memdesc:ae6de6bd03035124effb4d18b4e731563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a size vector to fit inside a grid.  <a href="#ae6de6bd03035124effb4d18b4e731563">More...</a><br/></td></tr>
<tr class="separator:ae6de6bd03035124effb4d18b4e731563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79275b32044dd28cbc80174717390edb"><td class="memItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a79275b32044dd28cbc80174717390edb">ScaleVector3</a> (Vector3 scl)</td></tr>
<tr class="separator:a79275b32044dd28cbc80174717390edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437b66750aeaf03cae546a2f1ad76d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a437b66750aeaf03cae546a2f1ad76d2d">ScaleTransform</a> (Transform theTransform, <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> ignoreAxis)</td></tr>
<tr class="memdesc:a437b66750aeaf03cae546a2f1ad76d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a Transform to fit the grid (without moving it).  <a href="#a437b66750aeaf03cae546a2f1ad76d2d">More...</a><br/></td></tr>
<tr class="separator:a437b66750aeaf03cae546a2f1ad76d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad5045b098fde4cea93afeadc1c419d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a9ad5045b098fde4cea93afeadc1c419d">ScaleTransform</a> (Transform theTransform)</td></tr>
<tr class="separator:a9ad5045b098fde4cea93afeadc1c419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52320338d1214f2ad84218bef0daeb52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a52320338d1214f2ad84218bef0daeb52">RenderGrid</a> (Vector3 from, Vector3 to, <a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a> colors, int width=0, Camera cam=null, Transform camTransform=null)</td></tr>
<tr class="memdesc:a52320338d1214f2ad84218bef0daeb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the grid at runtime <a href="#a52320338d1214f2ad84218bef0daeb52">More...</a><br/></td></tr>
<tr class="separator:a52320338d1214f2ad84218bef0daeb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24008f73b2c2ce9d6a699d25df998055"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a24008f73b2c2ce9d6a699d25df998055">RenderGrid</a> (int width=0, Camera cam=null, Transform camTransform=null)</td></tr>
<tr class="separator:a24008f73b2c2ce9d6a699d25df998055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af700a9a1f9e9f312b1eb55eb8752253c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#af700a9a1f9e9f312b1eb55eb8752253c">RenderGrid</a> (Vector3 from, Vector3 to, int width=0, Camera cam=null, Transform camTransform=null)</td></tr>
<tr class="separator:af700a9a1f9e9f312b1eb55eb8752253c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad728b4aecadb093c4a6873de26528d4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#ad728b4aecadb093c4a6873de26528d4c">DrawGrid</a> (Vector3 from, Vector3 to)</td></tr>
<tr class="memdesc:ad728b4aecadb093c4a6873de26528d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the grid using gizmos.  <a href="#ad728b4aecadb093c4a6873de26528d4c">More...</a><br/></td></tr>
<tr class="separator:ad728b4aecadb093c4a6873de26528d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4c12b9412837d32b268d145e04b26a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a9a4c12b9412837d32b268d145e04b26a">DrawGrid</a> ()</td></tr>
<tr class="separator:a9a4c12b9412837d32b268d145e04b26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5ed4cfa330e04e6ce8c951744b839"><td class="memItemLeft" align="right" valign="top">Vector3[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a21a5ed4cfa330e04e6ce8c951744b839">GetVectrosityPoints</a> (Vector3 from, Vector3 to)</td></tr>
<tr class="memdesc:a21a5ed4cfa330e04e6ce8c951744b839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of Vector3 points ready for use with Vectrosity.  <a href="#a21a5ed4cfa330e04e6ce8c951744b839">More...</a><br/></td></tr>
<tr class="separator:a21a5ed4cfa330e04e6ce8c951744b839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee183793ee692d671e39aaa93f4928e"><td class="memItemLeft" align="right" valign="top">Vector3[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a8ee183793ee692d671e39aaa93f4928e">GetVectrosityPoints</a> ()</td></tr>
<tr class="separator:a8ee183793ee692d671e39aaa93f4928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cd898dc26179856ac298b5213e6dfb"><td class="memItemLeft" align="right" valign="top">Vector3[][]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a53cd898dc26179856ac298b5213e6dfb">GetVectrosityPointsSeparate</a> (Vector3 from, Vector3 to)</td></tr>
<tr class="memdesc:a53cd898dc26179856ac298b5213e6dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of arrays of Vector3 points ready for use with Vectrosity.  <a href="#a53cd898dc26179856ac298b5213e6dfb">More...</a><br/></td></tr>
<tr class="separator:a53cd898dc26179856ac298b5213e6dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0d4962f326ba00115a40a2b82d0aa7"><td class="memItemLeft" align="right" valign="top">Vector3[][]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a9c0d4962f326ba00115a40a2b82d0aa7">GetVectrosityPointsSeparate</a> ()</td></tr>
<tr class="separator:a9c0d4962f326ba00115a40a2b82d0aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6fb374bcb7d726ff28e3f14817260d6c"><td class="memItemLeft" align="right" valign="top">Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a6fb374bcb7d726ff28e3f14817260d6c">originOffset</a> = Vector3.zero</td></tr>
<tr class="memdesc:a6fb374bcb7d726ff28e3f14817260d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to add to the origin <a href="#a6fb374bcb7d726ff28e3f14817260d6c">More...</a><br/></td></tr>
<tr class="separator:a6fb374bcb7d726ff28e3f14817260d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c8a71a08150d42b8c77186b12da656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a79c8a71a08150d42b8c77186b12da656">axisColors</a> = new <a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>()</td></tr>
<tr class="memdesc:a79c8a71a08150d42b8c77186b12da656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colours of the axes when drawing and rendering.  <a href="#a79c8a71a08150d42b8c77186b12da656">More...</a><br/></td></tr>
<tr class="separator:a79c8a71a08150d42b8c77186b12da656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb78dcbc2890d20556958c994b95b000"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#aeb78dcbc2890d20556958c994b95b000">useSeparateRenderColor</a> = false</td></tr>
<tr class="memdesc:aeb78dcbc2890d20556958c994b95b000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to use the same colours for rendering as for drawing.  <a href="#aeb78dcbc2890d20556958c994b95b000">More...</a><br/></td></tr>
<tr class="separator:aeb78dcbc2890d20556958c994b95b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256de68c87e13f4f6a2dcbdf931c0930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a256de68c87e13f4f6a2dcbdf931c0930">renderAxisColors</a> = new <a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>(Color.gray)</td></tr>
<tr class="memdesc:a256de68c87e13f4f6a2dcbdf931c0930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate colours of the axes when rendering.  <a href="#a256de68c87e13f4f6a2dcbdf931c0930">More...</a><br/></td></tr>
<tr class="separator:a256de68c87e13f4f6a2dcbdf931c0930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a9e01aac581a365606ac8c1b4af64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#afa8a9e01aac581a365606ac8c1b4af64">hideGrid</a> = false</td></tr>
<tr class="memdesc:afa8a9e01aac581a365606ac8c1b4af64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to hide the grid completely.  <a href="#afa8a9e01aac581a365606ac8c1b4af64">More...</a><br/></td></tr>
<tr class="separator:afa8a9e01aac581a365606ac8c1b4af64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a57a01347c8ab0a6401aa210f875ab0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a9a57a01347c8ab0a6401aa210f875ab0">hideOnPlay</a> = false</td></tr>
<tr class="memdesc:a9a57a01347c8ab0a6401aa210f875ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to hide the grid in play mode.  <a href="#a9a57a01347c8ab0a6401aa210f875ab0">More...</a><br/></td></tr>
<tr class="separator:a9a57a01347c8ab0a6401aa210f875ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84be21761ea7d955e2353b4d3846dd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a84be21761ea7d955e2353b4d3846dd17">hideAxis</a> = new <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>()</td></tr>
<tr class="memdesc:a84be21761ea7d955e2353b4d3846dd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to hide just individual axes.  <a href="#a84be21761ea7d955e2353b4d3846dd17">More...</a><br/></td></tr>
<tr class="separator:a84be21761ea7d955e2353b4d3846dd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030e49e310751d9b1c7d08b57ca93358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a030e49e310751d9b1c7d08b57ca93358">drawOrigin</a> = false</td></tr>
<tr class="memdesc:a030e49e310751d9b1c7d08b57ca93358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to draw a little sphere at the origin of the grid.  <a href="#a030e49e310751d9b1c7d08b57ca93358">More...</a><br/></td></tr>
<tr class="separator:a030e49e310751d9b1c7d08b57ca93358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33c2e0823730157804456f4ffb51ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a8b33c2e0823730157804456f4ffb51ed">renderGrid</a> = true</td></tr>
<tr class="memdesc:a8b33c2e0823730157804456f4ffb51ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to render the grid at runtime.  <a href="#a8b33c2e0823730157804456f4ffb51ed">More...</a><br/></td></tr>
<tr class="separator:a8b33c2e0823730157804456f4ffb51ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a840197e72fa8b32fb905cc2a9a4d4a"><td class="memItemLeft" align="right" valign="top">Material&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a5a840197e72fa8b32fb905cc2a9a4d4a">renderMaterial</a> = null</td></tr>
<tr class="memdesc:a5a840197e72fa8b32fb905cc2a9a4d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The material for rendering, if none is given it uses a default material.  <a href="#a5a840197e72fa8b32fb905cc2a9a4d4a">More...</a><br/></td></tr>
<tr class="separator:a5a840197e72fa8b32fb905cc2a9a4d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a65d207e3957240c935645db01a199419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a65d207e3957240c935645db01a199419">relativeSize</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a65d207e3957240c935645db01a199419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the drawing/rendering will scale with spacing.  <a href="#a65d207e3957240c935645db01a199419">More...</a><br/></td></tr>
<tr class="separator:a65d207e3957240c935645db01a199419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336f54e5b5f677871876dc3d90cc611d"><td class="memItemLeft" align="right" valign="top">virtual Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a336f54e5b5f677871876dc3d90cc611d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the visual representation of the grid.  <a href="#a336f54e5b5f677871876dc3d90cc611d">More...</a><br/></td></tr>
<tr class="separator:a336f54e5b5f677871876dc3d90cc611d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4556eac3905975b9024addb169c629d8"><td class="memItemLeft" align="right" valign="top">virtual Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a4556eac3905975b9024addb169c629d8">renderFrom</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a4556eac3905975b9024addb169c629d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom lower limit for drawing/rendering.  <a href="#a4556eac3905975b9024addb169c629d8">More...</a><br/></td></tr>
<tr class="separator:a4556eac3905975b9024addb169c629d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ec4b040505718f58a7841087d9b72a"><td class="memItemLeft" align="right" valign="top">virtual Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#af9ec4b040505718f58a7841087d9b72a">renderTo</a><code> [get, set]</code></td></tr>
<tr class="memdesc:af9ec4b040505718f58a7841087d9b72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom upper limit for drawing/rendering.  <a href="#af9ec4b040505718f58a7841087d9b72a">More...</a><br/></td></tr>
<tr class="separator:af9ec4b040505718f58a7841087d9b72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb950aa31097c85e153cd9a642900a31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#acb950aa31097c85e153cd9a642900a31">useCustomRenderRange</a><code> [get, set]</code></td></tr>
<tr class="memdesc:acb950aa31097c85e153cd9a642900a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use you own values for the range of the rendering.  <a href="#acb950aa31097c85e153cd9a642900a31">More...</a><br/></td></tr>
<tr class="separator:acb950aa31097c85e153cd9a642900a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712a2e6fec379ea55a0a53ca5867216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#a6712a2e6fec379ea55a0a53ca5867216">renderLineWidth</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a6712a2e6fec379ea55a0a53ca5867216"><td class="mdescLeft">&#160;</td><td class="mdescRight">The width of the lines used when rendering the grid.  <a href="#a6712a2e6fec379ea55a0a53ca5867216">More...</a><br/></td></tr>
<tr class="separator:a6712a2e6fec379ea55a0a53ca5867216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="events"></a>
Events</h2></td></tr>
<tr class="memitem:af3bfbed41ba24f963e871921c663f1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_f_grid.html#a1b011f573c51561fbd9e411f821ba820">GridChangedDelegate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_grid.html#af3bfbed41ba24f963e871921c663f1f8">GridChangedEvent</a></td></tr>
<tr class="memdesc:af3bfbed41ba24f963e871921c663f1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An even that gets fired  <a href="#af3bfbed41ba24f963e871921c663f1f8">More...</a><br/></td></tr>
<tr class="separator:af3bfbed41ba24f963e871921c663f1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the standard class all grids are based on. Aside from providing a common set of variables and a template for what methods to use, this class has no practical meaning for end users. Use this as reference for what can be done without having to specify which type of grid you are using. For anything more specific you have to look at the child classes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ab1885761cfdee863857bcf43c44b212d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GFGrid.GridPlane</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum encapsulates the three grid planes: XY, XZ and YZ. You can also get the integer of enum items, where the integer corresponds to the missing axis (X = 0, Y = 1, Z = 2): </p>
<div class="fragment"><div class="line">*   <span class="comment">// UnityScrip:</span></div>
<div class="line">*   var myPlane: <a class="code" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GFGrid.GridPlane</a> = GFGrid.GFGridPlane.XZ;</div>
<div class="line">*   var planeIndex: <span class="keywordtype">int</span> = (int)myPlane; <span class="comment">// sets the variable to 1</span></div>
<div class="line">*   </div>
<div class="line">*   <span class="comment">// C#</span></div>
<div class="line">*   <a class="code" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GFGrid.GridPlane</a> myPlane = GFGrid.GFGridPlane.XZ;</div>
<div class="line">*   <span class="keywordtype">int</span> planeIndex = (int)myPlane;</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a07c627c04505a6a0263ab69d3a08cc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.AlignTransform </td>
          <td>(</td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>theTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td>
          <td class="paramname"><em>ignoreAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theTransform</td><td>The Transform to align. </td></tr>
    <tr><td class="paramname">ignoreAxis</td><td>Which axes should be ignored. </td></tr>
    <tr><td class="paramname">rotate</td><td>Whether to rotate to the grid</td></tr>
  </table>
  </dd>
</dl>
<p>Fits an object inside the grid by using the object’s Transform. Setting <code>doRotate</code> makes the object take on the grid’s rotation. The parameter <code>lockAxis</code> makes the function not touch the corresponding coordinate.</p>
<p>The resulting position depends on <code><a class="el" href="class_g_f_grid.html#a188915803f5c902786ae413e7e939bfb" title="Fits a position vector into the grid. ">AlignVector3</a></code>, so please look up how that method works. </p>

</div>
</div>
<a class="anchor" id="a66b4191eeae96aa23f0ced78f4cc7e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.AlignTransform </td>
          <td>(</td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>theTransform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It aligns and rotates the Transform while respecting all axes, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a07c627c04505a6a0263ab69d3a08cc16">AlignTransform</a>(theTransform, <span class="keyword">true</span>, <span class="keyword">new</span> <a class="code" href="class_g_f_bool_vector3.html">GFBoolVector3</a>(<span class="keyword">false</span>));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a05264e68cae2826694f397e848d58bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.AlignTransform </td>
          <td>(</td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>theTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td>
          <td class="paramname"><em>lockAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It aligns and rotates the Transform but leaves the axes to the user, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a07c627c04505a6a0263ab69d3a08cc16">AlignTransform</a>(theTransform, <span class="keyword">true</span>, lockAxis);</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a05a7ee949a05d384656ea1b0befbe485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.AlignTransform </td>
          <td>(</td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>theTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It aligns and respects all axes to the user, but leaves the decision of rotation to the user, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a07c627c04505a6a0263ab69d3a08cc16">AlignTransform</a>(theTransform, rotate, <span class="keyword">new</span> <a class="code" href="class_g_f_bool_vector3.html">GFBoolVector3</a>(<span class="keyword">false</span>));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a188915803f5c902786ae413e7e939bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.AlignVector3 </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td>
          <td class="paramname"><em>ignoreAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position to align. </td></tr>
    <tr><td class="paramname">scale</td><td>A simulated scale to decide how exactly to fit the poistion into the grid. </td></tr>
    <tr><td class="paramname">ignoreAxis</td><td>Which axes should be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aligned position vector.</dd></dl>
<p>Fits a position inside the grid by using the object’s transform. The exact position depends on whether the components of <code>scale</code> are even or odd and the exact implementation can be found in the subclasses. The parameter <code>lockAxis</code> makes the function not touch the corresponding coordinate. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#a2e75c1892f5d91a3c9413fa32a3cb2c4">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a0cdd33751253349ae124d506f600bc7a">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#ac4cf783d960bf0d900d267e6bb7660b1">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a2c87287a14b02923c9c28aa9d7478eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 GFGrid.AlignVector3 </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It aligns the position while respecting all axes and uses a default size of 1 x 1 x 1, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a188915803f5c902786ae413e7e939bfb">AlignVector3</a>(pos, Vector3.one, <span class="keyword">new</span> <a class="code" href="class_g_f_bool_vector3.html">GFBoolVector3</a>(<span class="keyword">false</span>));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac77e71d071ad1d154df8dd6629765def"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 GFGrid.AlignVector3 </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td>
          <td class="paramname"><em>lockAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It aligns the position and uses a default size of 1 x 1 x 1 while leaving the axes to the user, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a188915803f5c902786ae413e7e939bfb">AlignVector3</a>(pos, Vector3.one, lockAxis);</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac08b9392f196d7c87133e343cee64824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 GFGrid.AlignVector3 </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It aligns the position and respects the axes while using a default size of 1 x 1 x 1, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a188915803f5c902786ae413e7e939bfb">AlignVector3</a>(pos, scale, <span class="keyword">new</span> <a class="code" href="class_g_f_bool_vector3.html">GFBoolVector3</a>(<span class="keyword">false</span>));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad728b4aecadb093c4a6873de26528d4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFGrid.DrawGrid </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Lower limit of the drawing. </td></tr>
    <tr><td class="paramname">to</td><td>Upper limit s drawing.</td></tr>
  </table>
  </dd>
</dl>
<p>This method draws the grid in the editor using gizmos. There is usually no reason to call this method manually, you should instead set the drawing flags of the grid itself. However, if you must, call this method from inside <code><a href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnDrawGizmos.html">OnDrawGizmos</a></code>. </p>

<p>Reimplemented in <a class="el" href="class_g_f_hex_grid.html#a9bef25619499d9275b4ccec9436ebc81">GFHexGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a9a4c12b9412837d32b268d145e04b26a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFGrid.DrawGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Uses the size as limits, it is equivalent to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a9a4c12b9412837d32b268d145e04b26a">DrawGrid</a>(-<a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>, <a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>);</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>Reimplemented in <a class="el" href="class_g_f_polar_grid.html#aef53bbc9278b35a3a7849f7339d3a2f7">GFPolarGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a21a5ed4cfa330e04e6ce8c951744b839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [] GFGrid.GetVectrosityPoints </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Lower limit for the points. </td></tr>
    <tr><td class="paramname">to</td><td>Upper limit for the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of points in local space.</dd></dl>
<p>Returns an array of Vector3 containing the points for a discrete vector line in Vectrosity. One entry is the starting point, the next entry is the end point, the next entry is the starting point of the next line and so on. </p>

</div>
</div>
<a class="anchor" id="a8ee183793ee692d671e39aaa93f4928e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [] GFGrid.GetVectrosityPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Uses the grid's <code><a class="el" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d" title="The size of the visual representation of the grid. ">size</a></code> as limits, equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a8ee183793ee692d671e39aaa93f4928e">GetVectrosityPoints</a>(-<a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>, <a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>);</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a53cd898dc26179856ac298b5213e6dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [][] GFGrid.GetVectrosityPointsSeparate </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Lower limit for the points. </td></tr>
    <tr><td class="paramname">to</td><td>Upper limit for the points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jagged array of three arrays, each containing the points of a single axis.</dd></dl>
<p>This method is very similar to <code><a class="el" href="class_g_f_grid.html#a21a5ed4cfa330e04e6ce8c951744b839" title="Returns an array of Vector3 points ready for use with Vectrosity. ">GetVectrosityPoints</a></code>, except that the points are in separate arrays for each axis. This is useful if you want to treat the lines of each axis differently, like having different colours. </p>

</div>
</div>
<a class="anchor" id="a9c0d4962f326ba00115a40a2b82d0aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [][] GFGrid.GetVectrosityPointsSeparate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Uses the grid's <code><a class="el" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d" title="The size of the visual representation of the grid. ">size</a></code> as limits, equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a9c0d4962f326ba00115a40a2b82d0aa7">GetVectrosityPointsSeparate</a>(-<a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>, <a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>);</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1b011f573c51561fbd9e411f821ba820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void GFGrid.GridChangedDelegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_f_grid.html">GFGrid</a>&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid that calls the delegate</td></tr>
  </table>
  </dd>
</dl>
<p>This is the delegate type for methods to be called when changes to the grid occur. It is best used together with the <a class="el" href="class_g_f_grid.html#af3bfbed41ba24f963e871921c663f1f8" title="An even that gets fired ">GridChangedEvent</a> event. </p>

</div>
</div>
<a class="anchor" id="af32d7bfcecb5da3fdc47b972b551e33e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.GridToWorld </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>gridPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gridPoint</td><td>Point in grid space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>World coordinates of the grid point.</dd></dl>
<p>Takes in a point in grid space and converts it to world space. Some grids have several coordinate system, so look into the specific class for conversion methods from other coordinate systems. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#abac4ca6dba9e7ee8ed87f70cf4a7afc7">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a80a4698250b08f212f3681abadbc5012">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#acdc111b97728b0fef0c32e2d96d59f90">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="adb7c70449b2449c1e82132e6300cc1a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.NearestBoxG </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Grid position of the nearest box. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space.</td></tr>
  </table>
  </dd>
</dl>
<p>Similar to <code><a class="el" href="class_g_f_grid.html#a7eaa2821cf118bb4821bd2cbf40029da" title="Returns the grid position of the nearest vertex. ">NearestVertexG</a></code>, it returns the grid coordinates of a box in the grid. Since the box is enclosed by several vertices, the returned value is the point in between all of the vertices.</p>
<p>This is just an abstract template for the method, look into the specific class for exact implementation. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#ab038b99bc1bedfcdee8a0736c4ed1a1e">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a5a5927fdbcec405928ad849dbc224147">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#ada9ff98dfc7854458fcef81d7ef43920">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="ac87a6f38d74c0a6dd222bdd046d781c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.NearestBoxW </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doDebug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>World position of the nearest box. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space. </td></tr>
    <tr><td class="paramname">doDebug</td><td>If set to <code>true</code> draw a sphere at the destination.</td></tr>
  </table>
  </dd>
</dl>
<p>Similar to <code><a class="el" href="class_g_f_grid.html#a0e4705c12317b31bd470d265aaa265db" title="Returns the world position of the nearest vertex. ">NearestVertexW</a></code>, it returns the world coordinates of a box in the grid. Since the box is enclosed by several vertices, the returned value is the point in between all of the vertices. If <code>doDebug</code> is set a small gizmo box will drawn there.</p>
<p>This is just an abstract template for the method, look into the specific class for exact implementation. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#a3068d7213363eaa404958bf7a95372d0">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a57461d743744a4687327e3819649afcc">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#a370d98190140fbcd6f20c966567fec90">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="aac129f3df1da5cdbc31143ecc7db35d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.NearestFaceG </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GridPlane</a>&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Grid position of the nearest face. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space. </td></tr>
    <tr><td class="paramname">plane</td><td>Plane on which the face lies.</td></tr>
  </table>
  </dd>
</dl>
<p>Similar to <code><a class="el" href="class_g_f_grid.html#a7eaa2821cf118bb4821bd2cbf40029da" title="Returns the grid position of the nearest vertex. ">NearestVertexG</a></code>, it returns the grid coordinates of a face on the grid. Since the face is enclosed by several vertices, the returned value is the point in between all of the vertices. You also need to specify on which plane the face lies (optional for hex- and polar grids).</p>
<p>This is just an abstract template for the method, look into the specific class for exact implementation. </p>

<p>Implemented in <a class="el" href="class_g_f_rect_grid.html#ac619bea3997f98e525108864ab05b696">GFRectGrid</a>, and <a class="el" href="class_g_f_layered_grid.html#a5af848e6ee44af68a8c4748716925468">GFLayeredGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a6fd66db25066777d0c697b71adab5183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.NearestFaceW </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_grid.html#ab1885761cfdee863857bcf43c44b212d">GridPlane</a>&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doDebug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>World position of the nearest face. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space. </td></tr>
    <tr><td class="paramname">plane</td><td>Plane on which the face lies. </td></tr>
    <tr><td class="paramname">doDebug</td><td>If set to <code>true</code> draw a sphere at the destination.</td></tr>
  </table>
  </dd>
</dl>
<p>Similar to <code><a class="el" href="class_g_f_grid.html#a0e4705c12317b31bd470d265aaa265db" title="Returns the world position of the nearest vertex. ">NearestVertexW</a></code>, it returns the world coordinates of a face on the grid. Since the face is enclosed by several vertices, the returned value is the point in between all of the vertices. You also need to specify on which plane the face lies (optional for hex- and polar grids). If <code>doDebug</code> is set a small gizmo face will drawn there.</p>
<p>This is just an abstract template for the method, look into the specific class for exact implementation. </p>

<p>Implemented in <a class="el" href="class_g_f_rect_grid.html#a64512f51d317d0608171387ece2ea1b5">GFRectGrid</a>, and <a class="el" href="class_g_f_layered_grid.html#a0fad538e6ffb56209e76da00c357a3c9">GFLayeredGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a7eaa2821cf118bb4821bd2cbf40029da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.NearestVertexG </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Grid position of the nearest vertex.</dd></dl>
<p>Returns the position of the nerest vertex in grid coordinates from a given point in world space.</p>
<p>This is just an abstract template for the method, look into the specific class for exact implementation. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#ae335a549959829d91dcede4847d7168f">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a48edc154e42bdcf930674af6cfdee18c">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#a622f8b92672cda60fa0b871a8c696652">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a0e4705c12317b31bd470d265aaa265db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.NearestVertexW </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doDebug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space. </td></tr>
    <tr><td class="paramname">doDebug</td><td>If set to <code>true</code> draw a sphere at the destination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>World position of the nearest vertex.</dd></dl>
<p>Returns the world position of the nearest vertex from a given point in world space. If <code>doDebug</code> is set a small gizmo sphere will be drawn at that position.</p>
<p>This is just an abstract template for the method, look into the specific class for exact implementation. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#aa3e803a3567facf12848c80698ae72ae">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#aeccec90c1c0547ec035b7d86a449f327">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#a77d747c990c622c8224db91e1b214947">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a52320338d1214f2ad84218bef0daeb52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFGrid.RenderGrid </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Camera&#160;</td>
          <td class="paramname"><em>cam</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>camTransform</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Lower limit</td></tr>
    <tr><td class="paramname">to</td><td>Upper limit</td></tr>
    <tr><td class="paramname">colors</td><td>Colors for rendering</td></tr>
    <tr><td class="paramname">width</td><td>Width of the line</td></tr>
    <tr><td class="paramname">cam</td><td>Camera for rendering</td></tr>
    <tr><td class="paramname">camTransform</td><td>Transform of the camera</td></tr>
  </table>
  </dd>
</dl>
<p>Renders the grid with lower and upper limit, a given line width and individual colours for the three axes. If the lines have line width 1 they will be exactly one pixel wide, and if they have a larger with they will be rendered as billboards (always facing the camera). If there is no camera and camera Transform passed this won't be possible and the lines will default back to one pixel width.</p>
<p>It is not necessary to call this method manually, rather you should just set the <code><a class="el" href="class_g_f_grid.html#a8b33c2e0823730157804456f4ffb51ed" title="Whether to render the grid at runtime. ">renderGrid</a></code> flag to <code>true</code> and let Grid Framework take care of it. However, if you want total control use this method, usually from within an <code><a href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnPostRender.html">OnPostRender</a></code> method. </p>

<p>Reimplemented in <a class="el" href="class_g_f_hex_grid.html#a0d9e55603bf7576e0aa89619a9d51964">GFHexGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a24008f73b2c2ce9d6a699d25df998055"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFGrid.RenderGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Camera&#160;</td>
          <td class="paramname"><em>cam</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>camTransform</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Renders the grid using <code><a class="el" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d" title="The size of the visual representation of the grid. ">size</a></code> for lower and upper limits, equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a52320338d1214f2ad84218bef0daeb52">RenderGrid</a>(-<a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>, <a class="code" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d">size</a>, <a class="code" href="class_g_f_grid.html#aeb78dcbc2890d20556958c994b95b000">useSeparateRenderColor</a> ? <a class="code" href="class_g_f_grid.html#a256de68c87e13f4f6a2dcbdf931c0930">renderAxisColors</a> : <a class="code" href="class_g_f_grid.html#a79c8a71a08150d42b8c77186b12da656">axisColors</a>, width, cam, camTransform);</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>Reimplemented in <a class="el" href="class_g_f_polar_grid.html#a5c3dd0e599e358379dc7c83f31e1dc5f">GFPolarGrid</a>.</p>

</div>
</div>
<a class="anchor" id="af700a9a1f9e9f312b1eb55eb8752253c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.RenderGrid </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Camera&#160;</td>
          <td class="paramname"><em>cam</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>camTransform</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Renders the grid using <code><a class="el" href="class_g_f_grid.html#a79c8a71a08150d42b8c77186b12da656" title="Colours of the axes when drawing and rendering. ">axisColors</a></code> (or <code><a class="el" href="class_g_f_grid.html#a256de68c87e13f4f6a2dcbdf931c0930" title="Separate colours of the axes when rendering. ">renderAxisColors</a></code> if <code><a class="el" href="class_g_f_grid.html#aeb78dcbc2890d20556958c994b95b000" title="Whether to use the same colours for rendering as for drawing. ">useSeparateRenderColor</a></code> is <code>true</code>) as colours, equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a52320338d1214f2ad84218bef0daeb52">RenderGrid</a>(from, to, <a class="code" href="class_g_f_grid.html#aeb78dcbc2890d20556958c994b95b000">useSeparateRenderColor</a> ? <a class="code" href="class_g_f_grid.html#a256de68c87e13f4f6a2dcbdf931c0930">renderAxisColors</a> : <a class="code" href="class_g_f_grid.html#a79c8a71a08150d42b8c77186b12da656">axisColors</a>, width, cam, camTransform);</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a437b66750aeaf03cae546a2f1ad76d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.ScaleTransform </td>
          <td>(</td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>theTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td>
          <td class="paramname"><em>ignoreAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theTransform</td><td>the Transform to scale. </td></tr>
    <tr><td class="paramname">lockAxis</td><td>The axes to ignore.</td></tr>
  </table>
  </dd>
</dl>
<p>Scales a Transform to fit inside a grid. The parameter <code>lockAxis</code> makes the function not touch the corresponding coordinate.</p>
<p>The resulting position depends on <code><a class="el" href="class_g_f_grid.html#ae6de6bd03035124effb4d18b4e731563" title="Scales a size vector to fit inside a grid. ">ScaleVector3</a></code>, so please look up how that method works. </p>

</div>
</div>
<a class="anchor" id="a9ad5045b098fde4cea93afeadc1c419d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFGrid.ScaleTransform </td>
          <td>(</td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>theTransform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It scales the Transform while respecting all axes, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#a437b66750aeaf03cae546a2f1ad76d2d">ScaleTransform</a>(theTransform, <span class="keyword">new</span> <a class="code" href="class_g_f_bool_vector3.html">GFBoolVector3</a>(<span class="keyword">false</span>));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae6de6bd03035124effb4d18b4e731563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.ScaleVector3 </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>scl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>&#160;</td>
          <td class="paramname"><em>ignoreAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scl</td><td>The vector to scale. </td></tr>
    <tr><td class="paramname">lockAxis</td><td>The axes to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The re-scaled vector.</dd></dl>
<p>This method takes in a vector representing a size and fits it inside the grid. The <code>lockAxis</code> parameter lets you ignore individual axes. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#adcfb9b713e494d4714a3ff6045b91d68">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a3b2a59738516cf05f92ff94cc2c58030">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#a157af066c521914a50000f0cf87aa455">GFRectGrid</a>.</p>

</div>
</div>
<a class="anchor" id="a79275b32044dd28cbc80174717390edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 GFGrid.ScaleVector3 </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>scl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>It scales the size while respecting all axes, it is equal to </p>
<div class="fragment"><div class="line">* <a class="code" href="class_g_f_grid.html#ae6de6bd03035124effb4d18b4e731563">ScaleVector3</a>(scl, <span class="keyword">new</span> <a class="code" href="class_g_f_bool_vector3.html">GFBoolVector3</a>(<span class="keyword">false</span>));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3c424ac71404a8c87a958b5b5952eb0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract Vector3 GFGrid.WorldToGrid </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>Point in world space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Grid coordinates of the world point.</dd></dl>
<p>Takes in a point in world space and converts it to grid space. Some grids have several coordinate system, so look into the specific class for conversion methods to other coordinate systems. </p>

<p>Implemented in <a class="el" href="class_g_f_hex_grid.html#a476548c7582c1529de47f31ce891f4fd">GFHexGrid</a>, <a class="el" href="class_g_f_polar_grid.html#a925bc4556e0c7422f476409b4f48067e">GFPolarGrid</a>, and <a class="el" href="class_g_f_rect_grid.html#ac668541585726a76ba85d1e15ca45753">GFRectGrid</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a79c8a71a08150d42b8c77186b12da656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a> GFGrid.axisColors = new <a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The colours are stored as three separte entries, corresponding to the three separate axes. They will be used for both drawing an rendering, unless <code>useSeparateRenderColor</code> is set to <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a030e49e310751d9b1c7d08b57ca93358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.drawOrigin = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set to <code>true</code> a small gizmo sphere will be drawn at the origin of the grid. This is not a rendering, so it wil not appear in the game, it is intended to make selecting the grid in the editor easier. </p>

</div>
</div>
<a class="anchor" id="a84be21761ea7d955e2353b4d3846dd17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a> GFGrid.hideAxis = new <a class="el" href="class_g_f_bool_vector3.html">GFBoolVector3</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This hides the individual axes rather than the whole grid. </p>

</div>
</div>
<a class="anchor" id="afa8a9e01aac581a365606ac8c1b4af64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.hideGrid = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set to <code>true</code> the grid will be neither drawn nor rendered at all, it then takes precedence over all the other flags. </p>

</div>
</div>
<a class="anchor" id="a9a57a01347c8ab0a6401aa210f875ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.hideOnPlay = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is similar to <code>hideGrid</code>, but only active while in play mode. </p>

</div>
</div>
<a class="anchor" id="a6fb374bcb7d726ff28e3f14817260d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 GFGrid.originOffset = Vector3.zero</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default the origin of grids is at the world position of their gameObject (the position of the Transform), this offset allows you to move the grid's pivot point by adding a value to it. Keep in mind how this will affect the various grid coordinate systems, they are still relative to the grid's origin, not the Transform.</p>
<p>In other words, if a point at grid position (1, 2, 0) is at world position (4, 5, 0) and you add and offset of (1, 1, 0), then point's grid position will still be (1, 2, 0), but its world position will be (5, 6, 0). Here is an example: </p>
<div class="fragment"><div class="line">*  <a class="code" href="class_g_f_grid.html">GFGrid</a> myGrid;</div>
<div class="line">*  Vector3 gPos = <span class="keyword">new</span> Vector3 (1, 2, 3);</div>
<div class="line">*  Vector3 wPos = myGrid.GridToWorld (gPos); </div>
<div class="line">*  Debug.Log (wPos); <span class="comment">// prints (4, 5, 0)</span></div>
<div class="line">*  </div>
<div class="line">*  myGrid.pivotOffset = <span class="keyword">new</span> Vector3 (1, 1, 0);</div>
<div class="line">*  wPos = myGrid.GridToWorld (gPos); </div>
<div class="line">*  Debug.Log (wPos); <span class="comment">// prints (5, 6, 0)</span></div>
<div class="line">*  </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a256de68c87e13f4f6a2dcbdf931c0930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a> GFGrid.renderAxisColors = new <a class="el" href="class_g_f_color_vector3.html">GFColorVector3</a>(Color.gray)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default the colours of <code>axisColors</code> are used for rendering, however if you set <code><a class="el" href="class_g_f_grid.html#aeb78dcbc2890d20556958c994b95b000" title="Whether to use the same colours for rendering as for drawing. ">useSeparateRenderColor</a></code> to <code>true</code> these colours will be used instead. </p>

</div>
</div>
<a class="anchor" id="a8b33c2e0823730157804456f4ffb51ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.renderGrid = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The grid will only be rendered if this flag is set to <code>true</code>, otherwise you won't be able to see the grid in the game. </p>

</div>
</div>
<a class="anchor" id="a5a840197e72fa8b32fb905cc2a9a4d4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Material GFGrid.renderMaterial = null</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You can use you own material if you want control over the shader used, otherwise this default material will be used: </p>
<div class="fragment"><div class="line">*   <span class="keyword">new</span> Material(<span class="stringliteral">&quot;Shader \&quot;Lines/Colored Blended\&quot; {&quot;</span> +</div>
<div class="line">*       <span class="stringliteral">&quot;SubShader { Pass { &quot;</span> +</div>
<div class="line">*       <span class="stringliteral">&quot;   Blend SrcAlpha OneMinusSrcAlpha &quot;</span> +</div>
<div class="line">*       <span class="stringliteral">&quot;   ZWrite Off Cull Off Fog { Mode Off } &quot;</span> +</div>
<div class="line">*       <span class="stringliteral">&quot;   BindChannels {&quot;</span> +</div>
<div class="line">*       <span class="stringliteral">&quot;   Bind \&quot;vertex\&quot;, vertex Bind \&quot;color\&quot;, color }&quot;</span> +</div>
<div class="line">*       <span class="stringliteral">&quot;} } }&quot;</span> )</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aeb78dcbc2890d20556958c994b95b000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.useSeparateRenderColor = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you set this flag to <code>true</code> the rendering will use the colours of <code><a class="el" href="class_g_f_grid.html#a256de68c87e13f4f6a2dcbdf931c0930" title="Separate colours of the axes when rendering. ">renderAxisColors</a></code>, otherwise it will default to <code><a class="el" href="class_g_f_grid.html#a79c8a71a08150d42b8c77186b12da656" title="Colours of the axes when drawing and rendering. ">axisColors</a></code>. This is useful if you want to have different colours for rendering and drawing. For example, you could have a clearly visible grid in the editor to work with and a barely visible grid in the game while playing. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a65d207e3957240c935645db01a199419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.relativeSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set this to <code>true</code> if you want the drawing to have relative size, i.e. to scale with the spacing/radius or whatever the specific grid uses. Otherwise set it to <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a4556eac3905975b9024addb169c629d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Vector3 GFGrid.renderFrom</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When using a custom rendering range this is the lower left backward limit of the rendering/drawing. </p>

</div>
</div>
<a class="anchor" id="a6712a2e6fec379ea55a0a53ca5867216"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GFGrid.renderLineWidth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The width of the rendered lines, if it is set to 1 all lines will be one pixel wide, otherwise they will have the specified width in world units. </p>

</div>
</div>
<a class="anchor" id="af9ec4b040505718f58a7841087d9b72a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Vector3 GFGrid.renderTo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When using a custom rendering range this is the upper right forward limit of the rendering/drawing. </p>

</div>
</div>
<a class="anchor" id="a336f54e5b5f677871876dc3d90cc611d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Vector3 GFGrid.size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the size of the drawing and rendering of the grid. Keep in mind that the grid is infinitely large, the drawing is just a visual representation, stretching on all three directions from the origin. The size is either absolute or relative to the grid's other parameters, depending on the value of <code><a class="el" href="class_g_f_grid.html#a65d207e3957240c935645db01a199419" title="Whether the drawing/rendering will scale with spacing. ">relativeSize</a></code>. If you set <code><a class="el" href="class_g_f_grid.html#acb950aa31097c85e153cd9a642900a31" title="Use you own values for the range of the rendering. ">useCustomRenderRange</a></code> to <code>true</code> that range will override this <code>size</code>. </p>

</div>
</div>
<a class="anchor" id="acb950aa31097c85e153cd9a642900a31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFGrid.useCustomRenderRange</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this flagis set to <code>true</code> the grid rendering an drawing will use the values of <code><a class="el" href="class_g_f_grid.html#a4556eac3905975b9024addb169c629d8" title="Custom lower limit for drawing/rendering. ">renderFrom</a></code> and <code><a class="el" href="class_g_f_grid.html#af9ec4b040505718f58a7841087d9b72a" title="Custom upper limit for drawing/rendering. ">renderTo</a></code> as limits. Otherwise it will use the <code><a class="el" href="class_g_f_grid.html#a336f54e5b5f677871876dc3d90cc611d" title="The size of the visual representation of the grid. ">size</a></code> instead. </p>

</div>
</div>
<h2 class="groupheader">Event Documentation</h2>
<a class="anchor" id="af3bfbed41ba24f963e871921c663f1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_f_grid.html#a1b011f573c51561fbd9e411f821ba820">GridChangedDelegate</a> GFGrid.GridChangedEvent</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the event that gets fired when one of the grid's properties is changed. If the Transform (position or rotation) is changed this event will only be fired if there is a camera trying to render the grid or some other method tries to draw the gird (like drawing in the editor or calling <a class="el" href="class_g_f_grid.html#a21a5ed4cfa330e04e6ce8c951744b839" title="Returns an array of Vector3 points ready for use with Vectrosity. ">GetVectrosityPoints</a>). You can learn more about events ont he <a class="el" href="events.html">Events</a> page of the user manual. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Plugins/Grid Framework/Abstracts/GFGrid.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_g_f_grid.html">GFGrid</a></li>
    <li class="footer">Generated on Sun Dec 1 2013 23:37:36 for Grid Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
